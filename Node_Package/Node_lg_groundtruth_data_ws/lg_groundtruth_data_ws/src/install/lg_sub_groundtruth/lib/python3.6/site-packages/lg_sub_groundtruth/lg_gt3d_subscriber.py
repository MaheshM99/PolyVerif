import rclpy # Import the ROS client library for Python
from rclpy.node import Node # Enables the use of rclpy's Node class
from std_msgs.msg import Float64MultiArray # Enable use of the std_msgs/Float64MultiArray message type
from lgsvl_msgs.msg import Detection3DArray
from autoware_auto_msgs.msg import BoundingBoxArray
import numpy as np # NumPy Python library
from scipy.spatial import ConvexHull
from numpy import *

lgstamp = 0
autostamp = 0
autoware_boxes = BoundingBoxArray.boxes
class PublishingSubscriber(Node):
  """
  Create a PublishingSubscriber class, which is a subclass of the Node class.
  """

  def __init__(self):
    """
    Class constructor to set up the node
    """
   
    # Initiate the Node class's constructor and give it a name
    super().__init__('publishing_subscriber')
     
    # Create subscriber(s)    
     
    # The node subscribes to messages of type std_msgs/Float64MultiArray, over a topic named:
    #   /simulator/ground_truth/detections
    # The callback function is called as soon as a message is received.
    # The maximum number of queued messages is 10.
 
	# from lg simulator
    self.subscription_1 = self.create_subscription(Detection3DArray,'/simulator/ground_truth/detections',self.lg_callback,1)

	# from the autoware ad stack
    self.subscription_2 = self.create_subscription(BoundingBoxArray,'/lidars/lidar_bounding_boxes',self.autoware_callback,1)
    
    self.subscription_1  # prevent unused variable warning
    self.subscription_2 
    
#for lg_data
  def lg_callback(self, msg):
      global lgstamp
      global autostamp
      lgstamp = msg.header.stamp.sec

      # Process only frames which have groundtruth data in LG Simulator  
      if len(msg.detections) >  0:
         #print("The length of list is: ", len(msg.detections))
         self.itrate_data(msg) 
      else:
         print("The length of list is: ", len(msg.detections))
     
      #self.get_logger().info('Subscribed Data of LG Groundtruth Data : "%s"' % msg.detections['bbox'])  

  def autoware_callback(self, msg):
      global lgstamp
      global autostamp
      global autoware_boxes
      autostamp = msg.header.stamp.sec
      autoware_boxes = msg.boxes
#        self.get_logger().info('Subscribed Data of Autoware Data : "%s"' % msg)

#----Below code is for IOU 3D calculation
  def polygon_clip(self,subjectPolygon, clipPolygon):

      def inside(p):
          return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])

      def computeIntersection():
          dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]
          dp = [ s[0] - e[0], s[1] - e[1] ]
          n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
          n2 = s[0] * e[1] - s[1] * e[0] 
          n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
          return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]
      outputList = subjectPolygon
      cp1 = clipPolygon[-1]
      for clipVertex in clipPolygon:
         cp2 = clipVertex
         inputList = outputList
         outputList = []
         s = inputList[-1]
         for subjectVertex in inputList:
             e = subjectVertex
             if inside(e):
                if not inside(s):
                  outputList.append(computeIntersection())
                outputList.append(e)
             elif inside(s):
                outputList.append(computeIntersection())
             s = e
         cp1 = cp2
         if len(outputList) == 0:
            return None
      return(outputList) 

  def poly_area(self,x,y):
      """ Ref: http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates """
      return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))

  def convex_hull_intersection(self,p1, p2):
      """ Compute area of two convex hull's intersection area.
      p1,p2 are a list of (x,y) tuples of hull vertices.
      return a list of (x,y) for the intersection and its volume
      """
      inter_p = self.polygon_clip(p1,p2)
      if inter_p is not None:
         hull_inter = ConvexHull(inter_p)
         return inter_p, hull_inter.volume
      else:
         return None, 0.0

  def box3d_vol(self,corners):
      ''' corners: (8,3) no assumption on axis direction '''
      a = np.sqrt(np.sum((corners[0,:] - corners[1,:])**2))
      b = np.sqrt(np.sum((corners[1,:] - corners[2,:])**2))
      c = np.sqrt(np.sum((corners[0,:] - corners[4,:])**2))
      return a*b*c

  def is_clockwise(self,p):
      x = p[:,0]
      y = p[:,1]
      return np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)) > 0

  def box3d_iou(self,corners1, corners2):
      ''' Compute 3D bounding box IoU.
      Input:
          corners1: numpy array (8,3), assume up direction is negative Y
          corners2: numpy array (8,3), assume up direction is negative Y
      Output:
          iou: 3D bounding box IoU
          iou_2d: bird's eye view 2D bounding box IoU
      todo (kent): add more description on corner points' orders.
      '''
      # corner points are in counter clockwise order
      rect1 = [(corners1[i,0], corners1[i,2]) for i in range(3,-1,-1)]
      rect2 = [(corners2[i,0], corners2[i,2]) for i in range(3,-1,-1)] 
    
      area1 = self.poly_area(np.array(rect1)[:,0], np.array(rect1)[:,1])
      area2 = self.poly_area(np.array(rect2)[:,0], np.array(rect2)[:,1])
   
      inter, inter_area = self.convex_hull_intersection(rect1, rect2)
      iou_2d = inter_area/(area1+area2-inter_area)
      ymax = min(corners1[0,1], corners2[0,1])
      ymin = max(corners1[4,1], corners2[4,1])

      inter_vol = inter_area * max(0.0, ymax-ymin)
    
      vol1 = self.box3d_vol(corners1)
      vol2 = self.box3d_vol(corners2)
      iou = inter_vol / (vol1 + vol2 - inter_vol)
      return iou, iou_2d

  def get_3d_box(self,box_size, heading_angle, center):
      ''' Calculate 3D bounding box corners from its parameterization.
      Input:
          box_size: tuple of (length,wide,height)
          heading_angle: rad scalar, clockwise from pos x axis
          center: tuple of (x,y,z)
      Output:
          corners_3d: numpy array of shape (8,3) for 3D box cornders
      '''
      def roty(t):
          c = np.cos(t)
          s = np.sin(t)
          return np.array([[c,  0,  s],
                           [0,  1,  0],
                           [-s, 0,  c]])

      R = roty(heading_angle)
      l,w,h = box_size
      x_corners = [l/2,l/2,-l/2,-l/2,l/2,l/2,-l/2,-l/2];
      y_corners = [h/2,h/2,h/2,h/2,-h/2,-h/2,-h/2,-h/2];
      z_corners = [w/2,-w/2,-w/2,w/2,w/2,-w/2,-w/2,w/2];
      corners_3d = np.dot(R, np.vstack([x_corners,y_corners,z_corners]))
      corners_3d[0,:] = corners_3d[0,:] + center[0];
      corners_3d[1,:] = corners_3d[1,:] + center[1];
      corners_3d[2,:] = corners_3d[2,:] + center[2];
      corners_3d = np.transpose(corners_3d)
      return corners_3d

#-----------------------------------------

  def itrate_data(self,msg):
      print("Checking time stamp data of lg with autoware : ")
      if lgstamp == autostamp :
         print("lgstamp : ",lgstamp)
         c_lg_bbox = 0
         print("\n\nNumber of box in lG Groundtruth data", len(msg.detections))
         while len(msg.detections) > 0:
               # return the BoundingBox3D of lg simulator include(position, orientation, size)
               lg_pos = msg.detections[c_lg_bbox].bbox.position.position
               lg_orient = msg.detections[c_lg_bbox].bbox.position.orientation
               lg_size = msg.detections[c_lg_bbox].bbox.size

               x_center = lg_pos.x + ((lg_size.x / 2) * lg_orient.x)
               y_center = lg_pos.y + ((lg_size.y / 2) * lg_orient.y)
               z_center = lg_pos.z + ((lg_size.z / 2) * lg_orient.z)
               print("LG bounding box center : ",x_center,y_center, z_center)

               # Extract data from the autoware subscribe topic
               c_autoware_boxes = 0
               while len(autoware_boxes) > 0 :
                     ad_bbsize = autoware_boxes[c_autoware_boxes].size
                     ad_bbcentroid = autoware_boxes[c_autoware_boxes].centroid
                     print("AD bounding box center : ",ad_bbcentroid)
                     #print("Autoware  :", autoware_boxes[c_autoware_boxes])
                     #print("  lg x : ",msg.detections[c_lg_bbox].bbox.size.x)

                     # get_3d_box(box_size, heading_angle, center)
                     corners_3d_ground_lg  = self.get_3d_box((lg_size.x,lg_size.y, lg_size.z), -1.50, (x_center ,y_center ,z_center)) 
                     corners_3d_predict_ad = self.get_3d_box((ad_bbsize.x, ad_bbsize.y, ad_bbsize.z), -1.52, (ad_bbcentroid.x, ad_bbcentroid.y, ad_bbcentroid.z ))

                     (IOU_3d,IOU_2d) = self.box3d_iou(corners_3d_predict_ad,corners_3d_ground_lg)
                     print ("IOU :  ", IOU_3d,IOU_2d) #3d IoU/ 2d IoU of BEV(bird eye's view)

                     if len(autoware_boxes)-1 == c_autoware_boxes :
                        break;
               	     c_autoware_boxes = c_autoware_boxes + 1      

               if len(msg.detections)-1 == c_lg_bbox :
                  break;

               c_lg_bbox = c_lg_bbox + 1
               print("lg_box : ",c_lg_bbox)
               print("auto_box : ",c_autoware_boxes)
             
      else:
         print("Timestamp of lg groundtruth doesn't match with the autoware ")
       
def main(args=None):
 
  # Initialize the rclpy library
  rclpy.init(args=args)
 
  # Create the node
  publishing_subscriber = PublishingSubscriber()
 
  # Spin the node so the callback function is called.
  # Pull messages from any topics this node is subscribed to.
  # Publish any pending messages to the topics.
  rclpy.spin(publishing_subscriber)
 
  # Destroy the node explicitly
  # (optional - otherwise it will be done automatically
  # when the garbage collector destroys the node object)
  publishing_subscriber.destroy_node()
 
  # Shutdown the ROS client library for Python
  rclpy.shutdown()
 
if __name__ == '__main__':
  main()

